# How prepare for OAs and interviews (Opinionated)

**1. You Can’t Memorize; You Can Develop Muscle Memory**

DSA isn’t about memorizing solutions—it’s about building intuition. Solve problems every day. Chase that AC verdict. No shortcuts.

**Actionable Tip**: Create a Codeforces account and start with the easiest problems ([link](https://codeforces.com/problemset?order=BY_SOLVED_DESC)). Solve as many as you can each day. These easy wins keep you motivated and help you recognize patterns—far better than grinding through a curated problem list.

If you do this rigorously, you don’t need the rest of this blog.

**2. Consistency Over Speed**

The learning curve is steep, especially at first. Progress may be slow, but consistency is key. It’s not about racing through topics; it’s about deep understanding. Solving easy problems on Codeforces builds your comfort with implementation, giving you the confidence to tackle tougher concepts without relying on solutions.

**3. Focus on Key Algorithms**

There is no defined syllabus, but some algorithms are more important than others. Focus on these topics (at least)—:

- Binary Search
- Dynamic Programming
- DFS/BFS
- Dijkstra

**How to Learn a New Topic**

Learn from any resource that makes sense to you, then solve recommended problems if available. Afterward, tackle related problems from USACO—it’s a fantastic resource that pushes your understanding. For example, here’s a solid list for binary search: [USACO Binary Search](https://usaco.guide/silver/binary-search?lang=cpp#usaco).

If you’re not solving all the binary search problems you encounter, you'll struggle in coding tests/interviews. BFS/DFS? You should be solving these without fail.

Dynamic programming problems can be tough, but most hiring processes won’t ask the hardest ones. Aim for a high success rate here. Since **everyone** will ask these.

Graph problems like that require Dijkstra's or any shortest path algorithm should almost always be solvable.

Mastering these fundamentals will help you skip the rare, extremely difficult problems when needed.

**4. Compete to Learn Fast**

I wasn't the most aggressive competitor on Codeforces or CodeChef, but even limited participation taught me invaluable lessons—speed, debugging, and thinking under pressure. Competing forces you to optimize your approach and execution.

Beyond online contests, I also competed in offline school-level competitions and mock-solved INOI and ZCO past contests. This experience (which helped me reach IOITC in 11th and 12th grade) gave me a real taste of problem-solving under pressure. Competing occasionally can help break the fear barrier and sharpen your skills—try solving [these INOI problems](https://www.codechef.com/practice/zco-inoi-problems). Each problem should take no more than an hour on average.

**5. Recognize Key Patterns**

As you solve more problems, you'll start to see similarities in solutions for categories like dynamic programming, graph traversal, and binary search. This is a good sign—you’re developing your own patterns, which will help you code and debug more efficiently.

**Conclusion**

Solve problems. Solve more problems. Quantity builds speed and intuition. Quality builds understanding. You need to optimize for both.

Notice I didn’t mention LeetCode. To me, LeetCode feels like memorizing questions and hoping companies repeat them. Honestly, have you ever met anyone who enjoyed grinding LeetCode for six months? I haven't. The approach I’ve shared made me fall in love with coding. It may not be for everyone, but if it helps even one person, it’s worth it.
